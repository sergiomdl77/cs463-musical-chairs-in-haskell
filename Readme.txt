Saad Arshad
Sergio Delgado

1. For our program we have a newMVar which is created at line 46 that is mm <- newMVar True which means this MVar variable holds a bool that is set to true which means that the music is turned on and is playing. This MVar variable is shared with all of the player threads. The emcee controlls the music on line 61 where it takeMVar and then turns it off on line 63 where its putMVar mm False which means the music is now off, and the players need to sit down and find a chair.

For the chairs we made a list that is binded to ss on line 47 ss <- makeChairs 1 k which means the makeChairs function will make a chair from 1 to k (which is the number of players) but one less than the players. The makeChairs function is on line 153 and returns a list that is created recursively by calling itself. Each chair is created as a newMVar (i,bool) where i is the chair number and the bool is to represent whether the chair is open or taken.

2. For our program we have a function called findSeat which starts on line 118. The function takes in the playernumber, the list of chairs, and a lock. This is a recursive function that first extracts a chair MVar from the list and checks whether it is True or False (open or taken). To check we also created helper get functions as 'geti' and 'geto' which extract the number and the bool from the chair or player MVar. The findSeat function checks the chair and if its open it does a putMVar and sets the chair to false and then sets the player to true, meaning its still in the game and then prints out the chairnumber and the playernumber that sat in that chair. If the chair is not open it goes through the rest of the list recursively but first we put the MVar back with a false meaning the chair is taken. The base case is that the chairs list is empty meaning the player lost and did not find a chair.

3. In terms of programming challenges that we faced were learning about how threads work in haskell and what resources we had avialable to us. Binding variables to new objects. Then we had to learn the syntax for MVar usage and the concept of what an MVar is. We also had to learn how to read in an argument in haskell and then convert that IO input into an INT so we can use that later on on for the program. By now we were used to coding in haskell from previous hw and project 3 so the programming part was not that hard. It just took time to learn new material. The competition for resources was when the threads were looking for chair MVars and the cooperation was when the threads were waiting for the emcee to turn the music off so they could start running. 

4. The most straight forward task was the whole concept of the game because it is a simple game that everyone has played before, so we knew how the flow of the project was to take place. The hard part was creating recursive functions that would mimic the game. The part that felt laborious to us was finding a way to put the threads to sleep. So in haskell there is no thread.sleep or thread.wakeall so we had to find a creative way for the players to wait untill the music is turned off. Since the music MVar is shared through all of the threads we created a function called threadsleep which is the first thing that is called when startPlayers is called on line 96. The threadSleep takes the music variable on line 163. It first extracts the MVar with readMVar (so we dont have to putback) and checks if the music is false, which means it is turned off. If it is turned off it just returns, meaning it is done with the function. If the music is not false then it calls the function again with the same music so it just keeps running in a loop until the music MVar is set to False. This could be considered a loop because it is using a lot of cpu cycles but resources were not a concern for this program so we did not mind using this approach. 

5. When working on this program we ran into a bug where the program was going into a deadlock. This was happening because the emcee was trying to do a takeMVar from the chairs list but we forgot to do a putMVar when we found a chair. So the emcee kept trying to take a MVar while a different thread did not put it back which caused the program to be in a deadlock. We did not use debug.trace but instead we manually inspected our logic and did a lot of trial and error by commenting out code and seeing how far it was running before it deadlocked. when we commented out lines 65-68 we saw that there was no dead lock which showed us that we were trying to change an MVar that was not putback yet. 

6. For our program we used the proffessor's withlock function from class examples because we really liked it and we used it whenever we wanted to print. This helped us create print statements that were syncronized and printed properly as we wanted. The only problem in our program is that we did not solve a small printout bug. When the program runs it does everything in the game correctly but right after it prints the round number it immediately prints out the player that lost. It is a small bug where the lost player is printed first and then followed by all of the players that got sat. We left in some commented-out code that we used to debug and trace out program and we made sure to comment as much as we could.      

